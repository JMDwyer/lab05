function [] = senc(input_bits)


rand_inst = load('rand_inst.mat','rand_inst');
rand_data = rand_inst.rand_inst;
outbits = [];

for i = 1:50
 
    %break 4000 bits off of input bits
    prepend = input_bits((4000*(i-1)+1:4000*(i)))'; 

    %Multiply each element within the length 4000 vector of data bits by root2
    r2_prepend = sqrt(2).*prepend;
    bit_tone = r2_prepend.*(rand_data)';
    
    %make rand_inst line up next loop iteration
    padded_tone = [zeros(1,112),bit_tone,zeros(1,708)];

    %Flip bit_tone conjugate,prepend dc offset
    freq_symbol = [0,padded_tone,conj(fliplr(conj(padded_tone)))];

    %Take the IDFT
    time_symbol = ifft(freq_symbol);

    %useful variables
    L = length(time_symbol);
    n_plus = 120;

    %add a cyclic prefix, multiply by sqrt L
    cyclic_time_symbol = sqrt(L).*[time_symbol((L-n_plus+1):end),time_symbol]; 


    outbits = [outbits,cyclic_time_symbol];

end


%Build the training symbol
training_sample = [zeros(1,112),rand_data',zeros(1,708)];



training_symbol = [training_sample(),0,training_sample,fliplr(conj(training_sample))];
disp(length(training_symbol));


%Add the training symbol to the remaining bits
outbits = [training_symbol, outbits];
disp(length(outbits));


%Write to waveform
audiowrite('tx.wav', outbits, 44100, 'BitsPerSample', 24);

return
